# Mini-C Obfuscator

## Project Overview

This project implements a **Mini-C Obfuscator**, a tool designed to transform Mini-C source code into a functionally equivalent but significantly harder-to-understand version. This process, known as code obfuscation, is crucial for software security, intellectual property protection, and preventing reverse engineering.

The obfuscator operates by parsing the input Mini-C code into an Abstract Syntax Tree (AST), applying various obfuscation techniques to the AST, and then generating the obfuscated C code from the modified AST. It provides both a user-friendly Graphical User Interface (GUI) and a Command-Line Interface (CLI) for flexibility.

## Features (Obfuscation Techniques)

The obfuscator implements the following advanced techniques to enhance code obscurity:

1.  **Identifier Renaming**:
    * Replaces meaningful variable, function, struct, union, enum, and label names with short, meaningless, automatically generated names (e.g., `var1`, `xyz2`).
    * Preserves C reserved keywords and handles temporary names generated by other obfuscation passes to maintain consistency.

2.  **Dead Code Insertion**:
    * Inserts declarations of unused integer variables initialized with random values into various code blocks. These variables do not affect program execution but increase code size and complexity.
    * Example: `int deadcode_1 = 1532;`

3.  **Equivalent Expression Transformation**:
    * Transforms common binary operations into semantically identical but syntactically more complex forms.
    * Example: `a + b` becomes `a - (-b)`.
    * Example: `a - b` becomes `a + (-b)`.

4.  **Dummy Function Insertion**:
    * Injects entirely new, self-contained functions into the code. These functions contain dummy logic (variable declarations, conditional assignments, return statements) but are never called by the original program's execution flow.

5.  **Opaque Predicate Insertion**:
    * Inserts `if-else` statements with conditions that are always true or always false, but are constructed to appear non-obvious.
    * Both branches of these `if-else` statements typically contain dead code (e.g., dummy variable declarations), further complicating static analysis.
    * Example: `if (opaque_var_1 == 42) { ... } else { ... }` where `opaque_var_1` is initialized to `42`.

## Mini-C Language Scope

The obfuscator is designed for a subset of the C language, referred to as "Mini-C," which includes:
* Basic Data Types: `int`, `char`, `bool`
* Variables and Operators
* Control Flow: `if`, `else`, `while`, `for`, `return`
* Functions with parameters and return values
* Input/Output: `printf`, `scanf`
* **Exclusions**: Does not support `struct` or `pointer` types.

## How to Run

### Dependencies

This project requires `pycparser` and `tkinter` (usually bundled with Python).
You can install `pycparser` using pip:

```bash
pip install pycparser
```

### GUI Mode

To run the obfuscator with the graphical user interface:

1.  Navigate to the project's root directory in your terminal.
2.  Execute the `main_ast.py` script:

    ```bash
    python main_ast.py
    ```

3.  **Using the GUI:**
    * **Import Input File**: Click the "Import" button to select your Mini-C source file (`.c` or `.mc` extension). The content will appear in the "Input Code" area.
    * **Select Output File**: The output file path will be automatically suggested (e.g., `input_obf.mc`). You can change it by clicking the "Save" button.
    * **Choose Obfuscation Techniques**: Select the desired obfuscation techniques using the checkboxes under "Obfuscation Techniques". All are enabled by default.
    * **Run Obfuscator**: Click the "Run Obfuscator" button. The obfuscated code will appear in the "Obfuscated Code" area and will be saved to the specified output file.
    * **Clear**: Click "Clear" to clear the text areas and reset file paths.

### CLI Mode

To run the obfuscator via the command-line interface:

1.  Navigate to the project's root directory in your terminal.
2.  Execute the `main_ast.py` script with the input file as an argument. All obfuscation techniques will be applied by default.

    ```bash
    python main_ast.py <input_file.mc> [output_file.mc]
    ```

    * `<input_file.mc>`: The path to your Mini-C source file (e.g., `my_program.mc`).
    * `[output_file.mc]`: (Optional) The path where the obfuscated code will be saved. If not provided, the output will be saved as `<input_file_name>_obf.mc` in the same directory as the input file.

    **Examples:**

    ```bash
    # Obfuscate 'example.mc' and save as 'example_obf.mc'
    python main_ast.py example.mc

    # Obfuscate 'source.c' and save as 'obfuscated_source.c'
    python main_ast.py source.c obfuscated_source.c
    ```

## Project Structure

```
.
├── main_ast.py                 # Main script (GUI & CLI logic, orchestrates obfuscations)
├── obfuscations/
│   ├── __init__.py             # Makes 'obfuscations' a Python package
│   ├── ast_rename.py           # Implements identifier renaming
│   ├── ast_dead_code.py        # Implements dead code insertion
│   ├── ast_equivalent_expr.py  # Implements equivalent expression transformation
│   ├── ast_dummy_function.py   # Implements dummy function insertion
│   └── ast_opaque_predicate.py # Implements opaque predicate insertion
└── <input_file.mc>             # Example input Mini-C file (user provided)
└── <output_file_obf.mc>        # Example obfuscated output file (generated)
```

## Functional Equivalence

The obfuscator is meticulously designed to ensure that the obfuscated code maintains **complete functional equivalence** with the original Mini-C program. This is achieved by:
* Operating directly on the Abstract Syntax Tree (AST), preserving the program's underlying logic and control flow.
* Implementing each obfuscation technique to be semantically neutral, meaning they modify only the superficial structure or add unreachable code without altering the program's runtime behavior or output.

## Team Members

* [Rozhin Khalilian]
* [Kimia Mazloomifar]
* [Alireza Karaminejad]

