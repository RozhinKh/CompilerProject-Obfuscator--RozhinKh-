# Mini-C Code Obfuscator

This project implements a code obfuscator for a subset of the C language, referred to as Mini-C. The primary goal of this tool is to transform Mini-C source code into a functionally equivalent version that is significantly harder for humans to understand and reverse-engineer, without altering its original behavior.

The obfuscator is built using ANTLR4 for all stages: lexical analysis, parsing, parse tree manipulation (for obfuscation transformations), and code generation.

## Features (Obfuscation Techniques Implemented)

This obfuscator applies several techniques to increase code obscurity:

1.  **Identifier Renaming:**
    * **Description:** Replaces meaningful variable, function, and struct names with arbitrary, meaningless identifiers (e.g., `sum` becomes `func_obf_1`, `total` becomes `var_obf_2`).
    * **Implementation:** Achieved by collecting identifiers during a parse tree traversal and applying a global mapping during the final code generation phase.

2.  **Dead Code Insertion:**
    * **Description:** Injects declarations of unused variables with random initial values into existing code blocks. These variables do not affect the program's execution but add visual clutter.
    * **Implementation:** A dedicated ANTLR visitor identifies `CompoundStatementContext` nodes and programmatically inserts new `TerminalNode` sequences representing variable declarations.

3.  **Dummy Function Insertion:**
    * **Description:** Adds entirely new, redundant function definitions to the source code. These functions contain arbitrary logic and return values that are never used by the original program.
    * **Implementation:** An ANTLR visitor modifies the `ProgramContext` to insert new `TerminalNode` sequences that form a basic, self-contained dummy function.

4.  **Opaque Predicate Integration:**
    * **Description:** Inserts conditional (`if-else`) statements where the condition's truth value is always known (either always true or always false), but is mathematically non-obvious. Both branches of the `if-else` statement contain dead code.
    * **Implementation:** An ANTLR visitor identifies `CompoundStatementContext` nodes and inserts new `TerminalNode` sequences representing an `if-else` block with a complex, but deterministic, condition and dead code in its branches.

5.  **Equivalent Expression Transformation (Limited):**
    * **Description:** Aims to replace simple arithmetic or logical expressions with functionally identical but more convoluted forms (e.g., `A + B` to `A - (~B) - 1`).
    * **Implementation Note:** Due to the inherent complexity and fragility of directly manipulating ANTLR parse tree structures for generic, complex expression transformations, this feature is currently a placeholder. Advanced transformations requiring significant subtree restructuring are challenging to implement robustly with direct ANTLR parse tree manipulation.

## Mini-C Language Scope

The obfuscator is designed for Mini-C, which includes:
* Basic data types: `int`, `char`, `bool`.
* Variables and operators.
* Control flow: `if`, `else`, `while`, `for`, `return`.
* Functions with parameters and return values.
* Input/output: `printf`, `scanf`.
* Support for `struct` and `pointer` syntax for parsing, but obfuscation techniques are not specifically applied to these constructs as per project requirements.

## Requirements

To run this obfuscator, you need:

* **Python 3.x**
* **ANTLR4 Python3 Runtime:**
    ```bash
    pip install antlr4-python3-runtime
    ```
* **ANTLR-generated Mini-C Parser Files:** You must have the following files generated by ANTLR from your `MiniC.g4` grammar in the same directory as the project scripts:
    * `MiniCLexer.py`
    * `MiniCParser.py`
    * `MiniCVisitor.py`
    * `MiniCListener.py`

## Installation

1.  **Clone the repository** (or download the project files).
2.  **Ensure ANTLR-generated files are present:** Place `MiniCLexer.py`, `MiniCParser.py`, `MiniCVisitor.py`, and `MiniCListener.py` in the project's root directory.
3.  **Install Python dependencies:**
    ```bash
    pip install antlr4-python3-runtime
    ```

## Usage

The obfuscator can be run in two modes: Graphical User Interface (GUI) or Command-Line Interface (CLI).

### 1. GUI Mode

To launch the GUI, simply run the `Main.py` script without any command-line arguments:

```bash
python Main.py
```

**GUI Instructions:**
* **"Load Code" Button:** Click to select an `*.mc` or `*.c` source file. Its content will appear in the "Original Source Code" area. An obfuscated output filename will be suggested.
* **"Save Result" Button:** Click to choose a different path/name for the obfuscated output file.
* **"Obfuscation Techniques" Checkboxes:** Select or deselect the obfuscation techniques you wish to apply.
* **"Run Obfuscation" Button:** Initiates the obfuscation process. The obfuscated code will appear in the "Obfuscated Output Code" area and be saved to the specified output file.
* **"Clear All Fields" Button:** Clears all text areas and resets file paths.

### 2. CLI Mode

To use the obfuscator from the command line, provide the input file path as an argument. You can optionally specify an output file path.

**Basic Usage:**

```bash
python Main.py <input_file.mc>
```
* This will read `input_file.mc`, apply all selected obfuscation techniques (by default), and save the output to `<input_file_base_name>_obfuscated.mc` in the same directory.

**Example:**
```bash
python Main.py my_program.mc
# Output will be saved to my_program_obfuscated.mc
```

**Specifying Output File:**

```bash
python Main.py <input_file.mc> <output_file.mc>
```
* This will read `input_file.mc`, apply all selected obfuscation techniques (by default), and save the output to `output_file.mc`.

**Example:**
```bash
python Main.py original.mc obfuscated_version.c
# Output will be saved to obfuscated_version.c
```

**Note on CLI Techniques:** In CLI mode, all implemented obfuscation techniques are applied by default. The CLI currently does not support selecting individual techniques via arguments.

## Project Structure

* `Main.py`: The main application script, handling GUI, CLI, file I/O, and orchestrating the ANTLR parsing, obfuscation, and code generation.
* `obfuscation_visitors.py`: Contains custom ANTLR `ParseTreeVisitor` implementations for each obfuscation technique (renaming, dead code, dummy functions, opaque predicates, and a placeholder for equivalent expressions). These visitors directly manipulate the ANTLR parse tree.
* `antlr_code_generator.py`: A custom ANTLR `ParseTreeVisitor` responsible for traversing the modified parse tree and generating the final C code string, applying identifier renaming.
* `MiniCLexer.py`: ANTLR-generated lexer for Mini-C.
* `MiniCParser.py`: ANTLR-generated parser for Mini-C.
* `MiniCVisitor.py`: ANTLR-generated base visitor for Mini-C.
* `MiniCListener.py`: ANTLR-generated base listener for Mini-C.

## Limitations and Notes

* **ANTLR Parse Tree Modification Complexity:** Directly modifying ANTLR parse trees for complex transformations (especially expressions or control flow flattening involving significant structural changes) is inherently challenging and can be fragile. The current implementation focuses on feasible direct manipulations (inserting tokens/nodes).
* **Equivalent Expression Transformation:** As noted, the `Equivalent Expression Transformation` is currently a placeholder due to the complexity of robustly implementing arbitrary expression transformations via direct ANTLR parse tree manipulation.
* **Functional Equivalence:** The primary objective is to maintain functional equivalence. Thorough testing with various Mini-C programs is crucial to verify that the obfuscated code behaves identically to the original.
* **Error Handling:** The obfuscator includes basic error handling for parsing and file operations, but complex semantic errors in the input Mini-C code might lead to unexpected behavior.

## Testing and Verification

To verify the obfuscator's effectiveness:
1.  Obfuscate a Mini-C program.
2.  Compile both the original and the obfuscated programs using a standard C compiler (e.g., GCC).
3.  Run both compiled executables with the same inputs.
4.  Compare their outputs to ensure they are identical.

## Team Information

* **Group Leader:** [RozhinKh]
* **Team Members:**
    * [KimiaMazloomifar]
    * [alirezaakj]
